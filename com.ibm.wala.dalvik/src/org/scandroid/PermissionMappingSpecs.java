/**
 *
 * Copyright (c) 2009-2012,
 *
 *  Galois, Inc. (Aaron Tomb <atomb@galois.com>, 
 *                Rogan Creswick <creswick@galois.com>, 
 *                Adam Foltzer <acfoltzer@galois.com>)
 *  Steve Suh    <suhsteve@gmail.com>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The names of the contributors may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 */
package org.scandroid;

import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.UTFDataFormatException;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.scandroid.spec.CallArgSinkSpec;
import org.scandroid.spec.CallArgSourceSpec;
import org.scandroid.spec.CallRetSourceSpec;
import org.scandroid.spec.ISpecs;
import org.scandroid.spec.MethodNamePattern;
import org.scandroid.spec.SinkSpec;
import org.scandroid.spec.SourceSpec;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.util.strings.StringStuff;

/**
 * An ISpecs implementation generated from the PScout permission mappings. The
 * inputstream these constructors expect is *not* the raw PScout file, but
 * rather a parsed version of that file that has been serialized as a
 * java.util.Map from permission names to sets of method signatures.
 * 
 * @author acfoltzer
 * 
 */
public class PermissionMappingSpecs implements ISpecs {
	private final Map<String, Set<String>> mappings;
	private final SourceSpec[] sources;
	private final SinkSpec[] sinks;

	/**
	 * Generate sources and sinks for all permissions in the given mappings
	 * 
	 * @param mappings
	 *            file generated by pscoutParser
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	@SuppressWarnings("unchecked")
	public PermissionMappingSpecs(InputStream mappingStream)
			throws ClassNotFoundException, IOException {
		this.mappings = (Map<String, Set<String>>) new ObjectInputStream(
				mappingStream).readObject();
		Set<SourceSpec> sourceSet = Sets.newHashSet();
		Set<SinkSpec> sinkSet = Sets.newHashSet();
		for (Entry<String, Set<String>> entry : mappings.entrySet()) {
			sourceSet.addAll(sourcesForSet(entry.getValue()));
			sinkSet.addAll(sinksForSet(entry.getValue()));
		}
		this.sources = (SourceSpec[]) sourceSet.toArray(new SourceSpec[sourceSet.size()]);
		this.sinks = (SinkSpec[]) sinkSet.toArray(new SinkSpec[sinkSet.size()]);
	}

	/**
	 * Generate sources and sinks only for those permissions specified.
	 * 
	 * @param mappingStream
	 *            file generated by pscoutParser
	 * @param sourcePermissions
	 *            for which to make sources
	 * @param sinkPermissions
	 *            for which to make sinks
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	public PermissionMappingSpecs(InputStream mappingStream,
			Set<String> sourcePermissions, Set<String> sinkPermissions)
			throws ClassNotFoundException, IOException {
		this.mappings = (Map<String, Set<String>>) new ObjectInputStream(
				mappingStream).readObject();
		Set<SourceSpec> sourceSet = Sets.newHashSet();
		Set<SinkSpec> sinkSet = Sets.newHashSet();

		for (String sourcePermission : sourcePermissions) {
			sourceSet.addAll(sourcesForSet(mappings.get(sourcePermission)));
		}

		for (String sinkPermission : sinkPermissions) {
			sinkSet.addAll(sinksForSet(mappings.get(sinkPermission)));
		}

		this.sources = (SourceSpec[]) sourceSet.toArray();
		this.sinks = (SinkSpec[]) sinkSet.toArray();
	}

	private List<SourceSpec> sourcesForSet(Set<String> set)
			throws UTFDataFormatException {
		List<SourceSpec> result = Lists.newLinkedList();
		for (String methodString : set) {
			MethodReference methodRef = StringStuff
					.makeMethodReference(methodString);
			MethodNamePattern pattern = MethodNamePattern
					.patternForReference(methodRef);

			// the pscout results don't record static vs. non-static, so we
			// assume it could be either

			int[] staticArgs = new int[methodRef.getNumberOfParameters()];
			for (int i = 0; i < staticArgs.length; i++) {
				staticArgs[i] = i;
			}
			int[] virtualArgs = new int[methodRef.getNumberOfParameters() + 1];
			for (int i = 0; i < virtualArgs.length; i++) {
				virtualArgs[i] = i;
			}

			result.add(new CallArgSourceSpec(pattern, staticArgs));
			result.add(new CallArgSourceSpec(pattern, virtualArgs));
			result.add(new CallRetSourceSpec(pattern, new int[] {}));
		}
		return result;
	}

	private List<SinkSpec> sinksForSet(Set<String> set)
			throws UTFDataFormatException {
		List<SinkSpec> result = Lists.newLinkedList();
		for (String methodString : set) {
			MethodReference methodRef = StringStuff
					.makeMethodReference(methodString);
			MethodNamePattern pattern = MethodNamePattern
					.patternForReference(methodRef);

			// the pscout results don't record static vs. non-static, so we
			// assume it could be either

			int[] staticArgs = new int[methodRef.getNumberOfParameters()];
			for (int i = 0; i < staticArgs.length; i++) {
				staticArgs[i] = i;
			}
			int[] virtualArgs = new int[methodRef.getNumberOfParameters() + 1];
			for (int i = 0; i < virtualArgs.length; i++) {
				virtualArgs[i] = i;
			}

			result.add(new CallArgSinkSpec(pattern, staticArgs));
			result.add(new CallArgSinkSpec(pattern, virtualArgs));
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.scandroid.spec.ISpecs#getEntrypointSpecs()
	 */
	@Override
	public MethodNamePattern[] getEntrypointSpecs() {
		return new MethodNamePattern[] {};
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.scandroid.spec.ISpecs#getSourceSpecs()
	 */
	@Override
	public SourceSpec[] getSourceSpecs() {
		return sources;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.scandroid.spec.ISpecs#getSinkSpecs()
	 */
	@Override
	public SinkSpec[] getSinkSpecs() {
		return sinks;
	}

}
